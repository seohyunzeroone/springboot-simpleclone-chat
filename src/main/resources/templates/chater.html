<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>Chat</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 20px; }
        #log { border: 1px solid #ddd; height: 320px; overflow-y: auto; padding: 8px; border-radius: 8px; }
        #controls { margin-top: 10px; display: flex; gap: 8px; }
        #msg { flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 6px; }
        button { padding: 8px 12px; border: 0; border-radius: 6px; background: #2f6feb; color: white; cursor: pointer; }
        button.secondary { background: #777; }
        .sys { color: #7a7a7a; font-style: italic; }
        .u { font-weight: 700; margin-right: 4px; }
    </style>
</head>
<body>
<h2>WebSocket Chat</h2>

<div id="log"></div>

<div id="controls">
    <input id="msg" type="text" placeholder="메시지를 입력하세요…" />
    <button id="sendBtn">보내기</button>
    <button id="leaveBtn" class="secondary">채팅방 나가기</button>
</div>

<script>
    const logEl = document.getElementById('log');
    const msgEl = document.getElementById('msg');
    const sendBtn = document.getElementById('sendBtn');
    const leaveBtn = document.getElementById('leaveBtn');

    // ===== 설정 =====
    const wsPath = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/chat';
    const keepAliveIntervalMs = 30000; // 30초 ping
    const maxBackoffMs = 30000;        // 재연결 최대 30초

    // ===== 상태 =====
    let ws = null;
    let leaving = false;               // '나가기' 눌렀는지 여부
    let reconnectAttempt = 0;
    let keepAliveTimer = null;
    let username = (localStorage.getItem('chat.username') || '').trim();
    let sentJoinForThisConnection = false;

    function ensureUsername() {
        while (!username) {
            const v = prompt('채팅에서 사용할 이름을 입력하세요:');
            if (v === null) break; // 사용자가 취소
            username = (v || '').trim();
        }
        if (username) localStorage.setItem('chat.username', username);
    }

    function appendLine(text, cls = '') {
        // "이름: 메시지" 형식이면 이름만 볼드 처리
        const idx = text.indexOf(':');
        const wrap = document.createElement('div');
        if (cls) wrap.className = cls;

        if (idx > 0) {
            const u = text.slice(0, idx);
            const m = text.slice(idx + 1).trimStart();
            const un = document.createElement('span');
            un.className = 'u';
            un.textContent = u + ':';
            const msg = document.createElement('span');
            msg.textContent = ' ' + m;
            wrap.appendChild(un);
            wrap.appendChild(msg);
        } else {
            wrap.textContent = text;
        }
        logEl.appendChild(wrap);
        logEl.scrollTop = logEl.scrollHeight;
    }

    function startKeepAlive() {
        stopKeepAlive();
        keepAliveTimer = setInterval(() => {
            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send('__ping__'); // 내부 keepalive. 화면에는 표시 안 함(아래 onmessage 필터)
                }
            } catch (_) {}
        }, keepAliveIntervalMs);
    }

    function stopKeepAlive() {
        if (keepAliveTimer) {
            clearInterval(keepAliveTimer);
            keepAliveTimer = null;
        }
    }

    function connect() {
        ws = new WebSocket(wsPath);

        ws.onopen = () => {
            reconnectAttempt = 0;
            appendLine('[연결됨]', 'sys');
            startKeepAlive();
            // 연결 성립 후 1회 입장 알림
            if (username && !sentJoinForThisConnection) {
                try { ws.send(`${username}: 님이 입장하셨습니다.`); } catch (_) {}
                sentJoinForThisConnection = true;
            }
        };

        // ✅ 여기! keepalive 메시지 숨김 처리
        ws.onmessage = (evt) => {
            if (evt.data === '__pong__' || evt.data === '__ping__') return; // 내부 keepalive 무시
            appendLine(evt.data);
        };

        ws.onclose = (evt) => {
            stopKeepAlive();
            sentJoinForThisConnection = false;
            if (leaving) {
                appendLine('[연결 종료]', 'sys');
                return;
            }
            appendLine(`[연결 끊김 - 자동 재연결 시도] (code=${evt.code})`, 'sys');
            scheduleReconnect();
        };

        ws.onerror = () => {
            // 일부 브라우저는 error 후 close가 이어짐
            appendLine('[오류 발생]', 'sys');
        };
    }

    function scheduleReconnect() {
        reconnectAttempt++;
        const wait = Math.min(1000 * Math.pow(2, reconnectAttempt), maxBackoffMs);
        setTimeout(() => {
            if (!leaving) connect();
        }, wait);
    }

    function sendMessage() {
        const text = msgEl.value.trim();
        if (!text) return;
        if (!username) {
            ensureUsername();
            if (!username) return; // 여전히 없음
        }
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(`${username}: ${text}`);
            msgEl.value = '';
        } else {
            appendLine('[아직 연결되지 않았습니다. 잠시 후 다시 시도하세요.]', 'sys');
        }
    }

    // UI 핸들러
    sendBtn.addEventListener('click', sendMessage);
    msgEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') sendMessage();
    });

    leaveBtn.addEventListener('click', () => {
        if (!username) ensureUsername();
        if (ws && ws.readyState === WebSocket.OPEN) {
            // 퇴장 알림 전송 후 정상 종료
            try { ws.send(`${username}: 님이 퇴장하셨습니다.`); } catch (_){}
            leaving = true;
            ws.close(1000, 'client-leave');
        }
    });

    // (선택) 탭 닫기/새로고침 경고
    window.addEventListener('beforeunload', (e) => {
        if (!leaving) {
            e.preventDefault();
            e.returnValue = '';
        }
    });

    // 초기: 이름 확보 후 연결
    ensureUsername();
    connect();
</script>
</body>
</html>
