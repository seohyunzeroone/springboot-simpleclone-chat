<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>Chat</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 20px; }
        #log { border: 1px solid #ddd; height: 320px; overflow-y: auto; padding: 8px; border-radius: 8px; }
        #controls { margin-top: 10px; display: flex; gap: 8px; }
        #msg { flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 6px; }
        button { padding: 8px 12px; border: 0; border-radius: 6px; background: #2f6feb; color: white; cursor: pointer; }
        button.secondary { background: #777; }
        .sys { color: #7a7a7a; font-style: italic; }
        .u { font-weight: 700; margin-right: 4px; }
    </style>
</head>
<body>
<h2>WebSocket Chat</h2>

<div id="log"></div>

<div id="controls">
    <input id="msg" type="text" placeholder="메시지를 입력하세요…" />
    <button id="sendBtn">보내기</button>
    <button id="leaveBtn" class="secondary">채팅방 나가기</button>
    <button id="renameBtn" class="secondary">닉네임 변경</button>
</div>

<script>
    const logEl = document.getElementById('log');
    const msgEl = document.getElementById('msg');
    const sendBtn = document.getElementById('sendBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const renameBtn = document.getElementById('renameBtn');

    const wsPath = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/chat';
    const keepAliveIntervalMs = 30000;
    const maxBackoffMs = 30000;

    let ws = null;
    let leaving = false;
    let reconnectAttempt = 0;
    let keepAliveTimer = null;
    let username = (localStorage.getItem('chat.username') || '').trim();
    let sentJoinForThisConnection = false;

    function promptUsername() {
        let v = '';
        while (!v) {
            v = prompt('채팅에서 사용할 이름을 입력하세요:');
            if (v === null) return; // 취소 시 종료
            v = (v || '').trim();
        }
        username = v;
        localStorage.setItem('chat.username', username);
    }

    function ensureUsername() {
        if (!username) promptUsername();
    }

    function appendLine(text, cls = '') {
        const idx = text.indexOf(':');
        const wrap = document.createElement('div');
        if (cls) wrap.className = cls;

        if (idx > 0) {
            const u = text.slice(0, idx);
            const m = text.slice(idx + 1).trimStart();
            const un = document.createElement('span');
            un.className = 'u';
            un.textContent = u + ':';
            const msg = document.createElement('span');
            msg.textContent = ' ' + m;
            wrap.appendChild(un);
            wrap.appendChild(msg);
        } else {
            wrap.textContent = text;
        }
        logEl.appendChild(wrap);
        logEl.scrollTop = logEl.scrollHeight;
    }

    function startKeepAlive() {
        stopKeepAlive();
        keepAliveTimer = setInterval(() => {
            try { if (ws && ws.readyState === WebSocket.OPEN) ws.send('__ping__'); } catch (_) {}
        }, keepAliveIntervalMs);
    }
    function stopKeepAlive() { if (keepAliveTimer) { clearInterval(keepAliveTimer); keepAliveTimer = null; } }

    function connect() {
        ws = new WebSocket(wsPath);

        ws.onopen = () => {
            reconnectAttempt = 0;
            appendLine('[연결됨]', 'sys');
            startKeepAlive();
            ensureUsername();
            if (username && !sentJoinForThisConnection) {
                try { ws.send(`${username}: 님이 입장하셨습니다.`); } catch (_) {}
                sentJoinForThisConnection = true;
            }
        };

        // ✅ keepalive 숨김
        ws.onmessage = (evt) => {
            if (evt.data === '__ping__' || evt.data === '__pong__') return;
            appendLine(evt.data);
        };

        ws.onclose = (evt) => {
            stopKeepAlive();
            sentJoinForThisConnection = false;
            if (leaving) { appendLine('[연결 종료]', 'sys'); return; }
            appendLine(`[연결 끊김 - 자동 재연결 시도] (code=${evt.code})`, 'sys');
            scheduleReconnect();
        };

        ws.onerror = () => appendLine('[오류 발생]', 'sys');
    }

    function scheduleReconnect() {
        reconnectAttempt++;
        const wait = Math.min(1000 * Math.pow(2, reconnectAttempt), maxBackoffMs);
        setTimeout(() => { if (!leaving) connect(); }, wait);
    }

    function sendMessage() {
        const text = msgEl.value.trim();
        if (!text) return;
        ensureUsername();
        if (!username) return;
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(`${username}: ${text}`);
            msgEl.value = '';
        } else {
            appendLine('[아직 연결되지 않았습니다. 잠시 후 다시 시도하세요.]', 'sys');
        }
    }

    // UI
    sendBtn.addEventListener('click', sendMessage);
    msgEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') sendMessage(); });

    leaveBtn.addEventListener('click', () => {
        ensureUsername();
        if (ws && ws.readyState === WebSocket.OPEN) {
            try { ws.send(`${username}: 님이 퇴장하셨습니다.`); } catch (_){}
            leaving = true;
            ws.close(1000, 'client-leave');
        }
    });

    renameBtn.addEventListener('click', () => {
        promptUsername();
        appendLine(`[닉네임이 '${username}'(으)로 설정되었습니다]`, 'sys');
    });

    // 처음 들어오면 닉네임부터
    ensureUsername();
    connect();
</script>
</body>
</html>
